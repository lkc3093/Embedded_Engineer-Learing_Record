# C++

* 构造函数与对象同名，用于初始化对象内的参数

  * 析构函数用于释放掉对象

* 对象可以继承，继承的称为子态，可以继承 `protected` 和 `public` 里面的函数和数据结构

* 模板可以用于多个相同功能的函数 / 对象，但是输入输出类型不一致的，通过模板方便编写

* `struct` 在 **C++** 中和对象类似

* ````C++
   using namespace std 
  ````

  ​			后缀为.h的头文件C++标注已经明确提出不支持了。早些的实现将标准库功能定义在全局空间里，声明在带.h后缀的头文件里，C++标准为了和C区别开，也为了正确地使用命名空间，规定头文件不使用后缀.h。因此，当使用<iostream.h>时，相当于在C中调用库函数，使用的是全局命名空间，也就是早期的C++实现。当使用<iostream>时，该头文件没有定义全局命名空间，必须使用namespace std，这样才能使用类似于cout这样的C++标识符。

  ​			这样命名空间std内定义的所有标识符都有效（曝光）。就好像它们被声明为全局变量一样。那么以上语句可以如下写: cout << hex << 3.4 << endl; 因为标准库非常的庞大，所以程序员在选择的类的名称或函数名时就很有可能和标准库中的某个名字相同。所以为了避免这种情况所造成的名字冲突，就把标准库中的一切都放在名字空间std中。但这有会带来了一个新问题。无数原有的C++代码都依赖于使用了多年的伪标准库中的功能，他们都是在全局空间下的，所以就有了 <iostream> 和`<iostream.h>` 等等这样的头文件，一个是为了兼容以前的C++代码，一个是为了支持新的标准。命名空间std封装的是标准程序库的名称，标准程序库为了和以前的头文件区别，一般都不加".h"。
  
* 子态可以继承多个父类



# **LLVM**

## **C++**
* `auto` 自动分配变量类型

## **后端** 
* `lib/target/riscv/targetinfo` 目录下有处理器的寄存器信息和指令集信息

* `lib/Codegen` 目录下是后端优化的代码

* `scheduleDAGSDNodes`, `scheduleDAGinstrs` 为指令调度算法

  

  <br><br>

# **TVM**

## **后端**
* 可以通过 `tensorize` 来定义硬化算子，实现加速器的支持
* 同一算法，不同的调度实现，划分子图
* 
* 计算调度分开，定义了算子的计算方式后，可以有不同的调度，测试对比，取性能最优的; 利用深度学习训练的`cost model`来快速评估